<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.7.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.7.0" type="image/png" sizes="32x32"><meta name="description" content="动态规划算法学习，递归写法和迭代写法的区别，动态规划与贪心算法、分治法的区别">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划算法学习">
<meta property="og:url" content="https://fengqianye.github.io/2022/09/22/dynamicProgramming/">
<meta property="og:site_name" content="枫玲的技术博客">
<meta property="og:description" content="动态规划算法学习，递归写法和迭代写法的区别，动态规划与贪心算法、分治法的区别">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/a268ccd36d95472485c88c26a6976323.png#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/ccd2911bfc52448bb9ab18235937ed1d.png#pic_center">
<meta property="article:published_time" content="2022-09-22T12:51:20.000Z">
<meta property="article:modified_time" content="2022-09-23T03:53:14.950Z">
<meta property="article:author" content="枫玲">
<meta property="article:tag" content="算法学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/a268ccd36d95472485c88c26a6976323.png#pic_center"><title>动态规划算法学习 | 枫玲的技术博客</title><link ref="canonical" href="https://fengqianye.github.io/2022/09/22/dynamicProgramming/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.7.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"dark","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: {"colWidth":"220px","gapX":"10px"},
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">枫玲的技术博客</div><div class="header-banner-info__subtitle">热爱生活和IT技术</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">动态规划算法学习</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-22</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-23</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.7k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">10分</span></span></div></header><div class="post-body">
        <h1 id="动态规划算法"   >
          <a href="#动态规划算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h1>
      
        <h2 id="动态规划的定义"   >
          <a href="#动态规划的定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#动态规划的定义" class="headerlink" title="动态规划的定义"></a>动态规划的定义</h2>
      <p>动态规划(Dynamic Programming, DP) 是一种用来解决一类最优化问题的算法思想。简单来说，动态规划将一个 复杂的问题分解成若千个子问题，通过综合子问题的最优解来得到原问题的最优解。需要注意的是，动态规划会将每个求解过的子问题的解记录下来，这样当下一次碰到同样的子问题时，就可以直接使用之前记录的结果，而不是重复计算。注意:虽然动态规划采用这种方式来提高计算效率，但不能说这种做法就是动态规划的核心^(后面会说明这一点)。 一般可以使用递归或者递推的写法来实现动态规划，其中递归写法在此处又称作记忆化搜索。</p>

        <h1 id="动态规划法求解的特点"   >
          <a href="#动态规划法求解的特点" class="heading-link"><i class="fas fa-link"></i></a><a href="#动态规划法求解的特点" class="headerlink" title="动态规划法求解的特点"></a>动态规划法求解的特点</h1>
      <ul>
<li>最优子结构<br> 如果一个问题的最优解中包含了子问题的最优解，说明该问题具有最优子解决。</li>
<li>重叠子问题<br>动态规划算法的子问题不是相互独立的，而是有公共的部分，即有重叠子问题。</li>
</ul>

        <h2 id="动态规划法求解的思路"   >
          <a href="#动态规划法求解的思路" class="heading-link"><i class="fas fa-link"></i></a><a href="#动态规划法求解的思路" class="headerlink" title="动态规划法求解的思路"></a>动态规划法求解的思路</h2>
      <blockquote>
<ul>
<li>穷举分析</li>
<li>确定边界</li>
<li>找出规律，确定最优子结构</li>
</ul>
</blockquote>
<p>以斐波那契(Fibonacci) 数列为例:</p>

        <h3 id="1-穷举分析"   >
          <a href="#1-穷举分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-穷举分析" class="headerlink" title="1. 穷举分析"></a>1. 穷举分析</h3>
      <div class="table-container"><table>
<thead>
<tr>
<th align="center">n</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">f(n)</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">f(1)+f(0)</td>
<td align="center">f(2)+f(1)</td>
<td align="center">f(3)+f(2)</td>
<td align="center">f(4)+f(3)</td>
<td align="center">f(5)+f(4)</td>
</tr>
</tbody></table></div>

        <h3 id="2-确定边界"   >
          <a href="#2-确定边界" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-确定边界" class="headerlink" title="2. 确定边界"></a>2. 确定边界</h3>
      <p>f(0)&#x3D;1<br>f(1)&#x3D;1<br>f(2)&#x3D;f(0)+f(1)<br>….<br>f(n)&#x3D;f(n-2)+f(n-1)<br>所以边界为f(0)&#x3D;1,f(1)&#x3D;1</p>

        <h3 id="3-找规律，确定最优子结构"   >
          <a href="#3-找规律，确定最优子结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-找规律，确定最优子结构" class="headerlink" title="3. 找规律，确定最优子结构"></a>3. 找规律，确定最优子结构</h3>
      <p>n&gt;&#x3D;3时，已经呈现出规律 f(n) &#x3D; f(n-1) + f(n-2) ，因此，f(n-1)和f(n-2) 称为 f(n) 的最优子结构。什么是最优子结构？有这么一个解释：</p>
<blockquote>
<p>一道动态规划问题，其实就是一个递推问题。假设当前决策结果是f(n),则最优子结构就是要让 f(n-k) 最&gt;优,最优子结构性质就是能让转移到n的状态是最优的,并且与后面的决策没有关系,即让后面的决策安心&gt;地使用前面的局部最优解的一种性质”</p>
</blockquote>

        <h2 id="动态规划的递归写法"   >
          <a href="#动态规划的递归写法" class="heading-link"><i class="fas fa-link"></i></a><a href="#动态规划的递归写法" class="headerlink" title="动态规划的递归写法"></a>动态规划的递归写法</h2>
      <p> 以斐波那契(Fibonacci) 数列为例，按下面的代码来计算的:</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">暴力递归</span><br><span class="line"><span class="type">int</span> <span class="title function_">F</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> F(n<span class="number">-1</span>)+F(n<span class="number">-2</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>
<p>  这个递归会涉及很多重复的计算。如图所示，当n&#x3D;5时，可以得到F(5)&#x3D; F(4)+ F(3)， 接下来在计算F(4)时又会有F(4)&#x3D; F(3)+ F(2)。 这时候如果不采取措施，F(3)将会被计算两次。可以推知，如果n很大，重复计算的次数将难以想象。事实上，由于没有及时保存中间计算的结果，实际复杂度会高达O(2^n),即每次都会计算F(n- 1)和F(n - 2)这两个分支，基本不能承受n较大的情况。<br>  
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/a268ccd36d95472485c88c26a6976323.png#pic_center"  alt="在这里插入图片描述">
      </p>
<p>为了避免重复计算，可以开一个一-维数组dp,用以保存已经计算过的结果中dp[n]记录F(n)的结果，并用dp[n]&#x3D;-1表示F(n)当前还没被计算过。样就把已经计算过的内容记录了下来，于是当下次再碰到需要计算相同的内容时，就能直接使用上次计算的结果，剪去已经有结果的树枝，这可以省去大半无效计算，而这也是记忆化搜索这个名字的由来。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[MAXN];</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">-1</span>,<span class="keyword">sizeof</span>(a));<span class="comment">//注意memset在&lt;string&gt;中，且只能赋值0或-1；</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">F</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(dp[n]!=<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> dp[n];</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		dp[n]=F(n<span class="number">-1</span>)+F(n<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">return</span> dp[n];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>特点：自顶向下<br>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/ccd2911bfc52448bb9ab18235937ed1d.png#pic_center"  alt="在这里插入图片描述">
      </p>

        <h2 id="动态规划的迭代写法"   >
          <a href="#动态规划的迭代写法" class="heading-link"><i class="fas fa-link"></i></a><a href="#动态规划的迭代写法" class="headerlink" title="动态规划的迭代写法"></a>动态规划的迭代写法</h2>
      <p> 以斐波那契(Fibonacci) 数列为例，按下面的代码来计算的:</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FibonacciD</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(num == <span class="number">1</span> || num == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> first = <span class="number">1</span>,second =<span class="number">1</span>,third = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i&lt;= num ;i++) &#123;</span><br><span class="line">			third = first + second;</span><br><span class="line">			first = second;</span><br><span class="line">			second = third;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> third;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></div></figure>
<p>特点：自底向上</p>

        <h2 id="动态规划的算法与其他算法的区别"   >
          <a href="#动态规划的算法与其他算法的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#动态规划的算法与其他算法的区别" class="headerlink" title="动态规划的算法与其他算法的区别"></a>动态规划的算法与其他算法的区别</h2>
      
        <h3 id="分治法与动态规划"   >
          <a href="#分治法与动态规划" class="heading-link"><i class="fas fa-link"></i></a><a href="#分治法与动态规划" class="headerlink" title="分治法与动态规划"></a>分治法与动态规划</h3>
      <p>   分治和动态规划都是将问题分解为子问题，然后合并子问题的解得到原问题的解。但是不同的是，分治法分解出的子问题是不重叠的，相互独立，因此分治法解决的问题不拥有重叠子问题，而动态规划解决的问题拥有重叠子问题。例如，归并排序和快速排序都是分别处理左序列和右序列，然后将左右序列的结果合并，过程中不出现重叠子问题，因此它们使用的都是分治法。另外，分治法解决的问题不一定是最优化问题，而动态规划解决的问题一-定是最优化问题。</p>

        <h3 id="贪心算法与动态规划"   >
          <a href="#贪心算法与动态规划" class="heading-link"><i class="fas fa-link"></i></a><a href="#贪心算法与动态规划" class="headerlink" title="贪心算法与动态规划"></a>贪心算法与动态规划</h3>
      <p>   贪心和动态规划都要求原问题必须拥有最优子结构。二者的区别在于，贪心法采用的计算方式类似于上面介绍的“自顶向下”,但是并不等待子问题求解完毕后再选择使用哪一个，而是通过一种策略直接选择-一个子 问题去求解，没被选择的子问题就不去求解了，直接抛弃。也就是说，它总是只在上一步选择的基础上继续选择，因此整个过程以一”种单链的流水方式进行，显然这种所谓“最优选择”的正确性需要用归纳法证明。例如对数塔问题而言，贪心法从最上层开始，每次选择左下和右下两个数字中较大的一个，一直到最底层得到最后结果，显然这不一定可以得到最优解。而动态规划不管是采用自底向上还是自顶向下的计算方式，都是从边界开始向上得到目标问题的解。也就是说，它总是会考虑所有子问题，并选择继承能得到最优结果的那个，对暂时没被继承的子问题，由于重叠子问题的存在，后期可能会再次考虑它们，因此还有机会成为全局最优的一部分，不需要放弃。所以贪心是一种壮士断腕的决策，只要进行了选择，就不后悔;动态规划则要看哪个选择笑到了最后，暂时的领先说明不了什么。</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://fengqianye.github.io">枫玲</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://fengqianye.github.io/2022/09/22/dynamicProgramming/">https://fengqianye.github.io/2022/09/22/dynamicProgramming/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://fengqianye.github.io/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/">算法学习</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2022/09/23/greedyAlgorithmLearn/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">贪心算法学习</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2022/09/21/webpackLearn/"><span class="paginator-prev__text">webpack的development和production模式</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">
          动态规划算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">
          动态规划的定义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B3%95%E6%B1%82%E8%A7%A3%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">
          动态规划法求解的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B3%95%E6%B1%82%E8%A7%A3%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">2.1.</span> <span class="toc-text">
          动态规划法求解的思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A9%B7%E4%B8%BE%E5%88%86%E6%9E%90"><span class="toc-number">2.1.1.</span> <span class="toc-text">
          1. 穷举分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A1%AE%E5%AE%9A%E8%BE%B9%E7%95%8C"><span class="toc-number">2.1.2.</span> <span class="toc-text">
          2. 确定边界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%89%BE%E8%A7%84%E5%BE%8B%EF%BC%8C%E7%A1%AE%E5%AE%9A%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.3.</span> <span class="toc-text">
          3. 找规律，确定最优子结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">
          动态规划的递归写法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%86%99%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">
          动态规划的迭代写法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.</span> <span class="toc-text">
          动态规划的算法与其他算法的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E6%B3%95%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">2.4.1.</span> <span class="toc-text">
          分治法与动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">2.4.2.</span> <span class="toc-text">
          贪心算法与动态规划</span></a></li></ol></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/stun-logo.svg" alt="avatar"></div><p class="sidebar-ov-author__text">学海无涯</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/fengqianye/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="1692413708" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">23</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">20</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">9</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>枫玲</span></div><div></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script src="/js/utils.js?v=2.7.0"></script><script src="/js/stun-boot.js?v=2.7.0"></script><script src="/js/scroll.js?v=2.7.0"></script><script src="/js/header.js?v=2.7.0"></script><script src="/js/sidebar.js?v=2.7.0"></script></body></html>